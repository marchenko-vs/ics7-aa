\chapter{Исследовательская часть}
\section{Технические характеристики устройства}

Технические характеристики устройства, на котором было проведено измерение времени работы алгоритмов сортировки:

\begin{enumerate}
\item[1)]
операционная система Windows 10 Pro x64;
\item[2)]
оперативная память 16 ГБ;
\item[3)]
процессор Intel\textregistered ~Core\texttrademark ~i7-4790K @ 4.00 ГГц.
\end{enumerate}

\section{Время работы алгоритмов}

В таблицах~\ref{tabular:firsttable}--\ref{tabular:lasttable} приведено время работы в тиках трех функций, реализующих алгоритмы сортировки при различных размерах входного массива. 
На рисунках~\ref{img:graph_1}--\ref{img:graph_3} изображены зависимости времени работы в тиках алгоритмов сортировки от размера входного массива.

Время работы функций замерены с помощью ассемблерной инструкции rdtsc, которая читает счетчик Time Stamp Counter и возвращает 64-битное количество тиков с момента последнего сброса процессора.

\begin{table}[H]
\caption{Время работы функций, реализующих алгоритмы сортировки, в зависимости от размеров входного упорядоченного по возрастанию массива}
\label{tabular:firsttable}
\begin{tabular}{|>{\raggedleft}p{3.5cm}|>{\raggedleft}p{4cm}|>{\raggedleft}p{4cm}|>{\raggedleft}p{4cm}|}
\hline
\textbf{Размер массива (элементы)} & \textbf{Блочная сортировка (тики)} & \textbf{Поразрядная сортировка (тики)} & \textbf{Сортировка перемешиванием (тики)} \tabularnewline
\hline
10 & 30126 & 9762 & 469 \tabularnewline
\hline
50 & 43202 & 17131 & 842 \tabularnewline
\hline
100 & 44411 & 18125 & 886 \tabularnewline
\hline
250 & 76321 & 59982 & 2187 \tabularnewline
\hline
500 & 113912 & 110664 & 3974 \tabularnewline
\hline
\end{tabular}
\end{table}

\includeimage
    {graph_1}
    {f}
    {H}
    {0.9\textwidth}
    {Зависимость времени работы функций, реализующих алгоритмы сортировки, в тиках от размеров входного упорядоченного по возрастанию массива}

\begin{table}[H]
\caption{Время работы функций, реализующих алгоритмы сортировки, в зависимости от размеров входного упорядоченного по убыванию массива}
\label{tabular:timeforward}
\begin{tabular}{|>{\raggedleft}p{3.5cm}|>{\raggedleft}p{4cm}|>{\raggedleft}p{4cm}|>{\raggedleft}p{4cm}|}
\hline
\textbf{Размер массива (элементы)} & \textbf{Блочная сортировка (тики)} & \textbf{Поразрядная сортировка (тики)} & \textbf{Сортировка перемешиванием (тики)} \tabularnewline
\hline
10 & 34547 & 9886 & 38376 \tabularnewline
\hline
50 & 64888 & 16952 & 145939 \tabularnewline
\hline
100 & 64895 & 18070 & 147250 \tabularnewline
\hline
250 & 220321 & 56900 & 1021819 \tabularnewline
\hline
500 & 1844674 & 109577 & 3575462 \tabularnewline
\hline
\end{tabular}
\end{table}

\includeimage
    {graph_2}
    {f}
    {H}
    {0.9\textwidth}
    {Зависимость времени работы функций, реализующих алгоритмы сортировки, в тиках от размеров входного упорядоченного по убыванию массива}

\begin{table}[H]
\caption{Время работы функций, реализующих алгоритмы сортировки, в зависимости от размеров входного случайно упорядоченного массива}
\label{tabular:lasttable}
\begin{tabular}{|>{\raggedleft}p{3.5cm}|>{\raggedleft}p{4cm}|>{\raggedleft}p{4cm}|>{\raggedleft}p{4cm}|}
\hline
\textbf{Размер массива (элементы)} & \textbf{Блочная сортировка (тики)} & \textbf{Поразрядная сортировка (тики)} & \textbf{Сортировка перемешиванием (тики)} \tabularnewline
\hline
10 & 36580 & 48053 & 31330 \tabularnewline
\hline
50 & 61390 & 86500 & 109334 \tabularnewline
\hline
100 & 62672 & 88012 & 109417 \tabularnewline
\hline
250 & 156227 & 200412 & 612988 \tabularnewline
\hline
500 & 428196 & 396996 & 2410021 \tabularnewline
\hline
\end{tabular}
\end{table}

\includeimage
    {graph_3}
    {f}
    {H}
    {0.9\textwidth}
    {Зависимость времени работы функций, реализующих алгоритмы сортировки, в тиках от размеров входного случайно упорядоченного массива}

\section*{Вывод}

Сортировка перемешиванием наименее затратна по времени, если на вход подается упорядоченный по возрастанию вектор. 
Если же массив заполнен случайными числами, то время работы сортировки перемешиванием растет значительно быстрее с увеличением размера вектора. 
В этом случае наиболее эффективно себя показывают блочная и подразрядная сортировки. Если вектор упорядочен по убыванию, быстрее других алгоритмов работает поразрядная сортировка.

Согласно полученным при проведении эксперимента данным, наиболее эффективной можно считать поразрядную сортировку, которая показала хорошие результаты относительно других алгоритмов во всех трех случаях. 
К тому же, она является наиболее эффективной в случае, когда на вход подается упорядоченный по убыванию массив.
