\chapter{Аналитическая часть}

\section{Цели и задачи}

Цель работы: изучить принципы конвейерной обработки данных и реализовать классический алгоритм поиска строки в тексте и алгоритм Кнута-Морриса-Пратта.

Задачи лабораторной работы:

\begin{enumerate}
\item[1)] изучить понятие конвейерной обработки данных;
\item[2)] реализовать классический алгоритм поиска строки в тексте и алгоритм Кнута-Морриса-Пратта;
\item[3)] реализовать последовательную обработку данных на основе двух алгоритмов поиска строки в тексте;
\item[4)] реализовать конвейерную обработку данных на основе двух алгоритмов поиска строки в тексте;
\item[5)] провести сравнительный анализ времени работы линейной и конвейерной обработки данных на основе экспериментальных данных.
\end{enumerate}

\section{Классический алгоритм поиска строки в тексте}

Первый приходящий в голову алгоритм для поиска строки $S$ в тексте $T$ последовательно проверяет равенство $S[1..m] = T[s + 1..s + m]$ для всех $n - m + 1$ возможных значений $s$ \cite{Cormen2013}.

Можно сказать, что мы двигаем строку вдоль текста и проверяем все ее положения \cite{Cormen2013}.

Время работы этого алгоритма в худшем случае есть $\Theta ((n - m + 1)m)$. 
В самом деле, пусть $T = a^n$ (буква $a$, повторенная $n$ раз), а $S = a^m$. 
Тогда для каждой из $n - m + 1$ проверок будет выполнено $m$ сравнений символов, всего $(n - m + 1)m$, что есть $\Theta (n^2)$ (при $m = [n / 2]$) \cite{Cormen2013}.

\section{Алгоритм Кнута-Морриса-Пратта}

Расмотрим алгоритм сравнения строк, который был предложен Кнутом, Моррисом и Праттом, и время работы которого линейно зависит от объема входных данных. 
В этом алгоритме удается избежать вычисления функции переходов $\delta$, а благодаря использованию вспомогательной функции $\pi [1..m]$, которая вычисляется по заданному образцу за время $\Theta (m)$, время сравнения в этом алгоритме равно $\Theta (n)$. 
Массив $\pi$ позволяет эффективно вычислять функцию $\delta$ <<на лету>>, т. е. по мере необходимости. 
Грубо говоря, для любого состояния $q = 0, 1, ..., m$ и любого символа $a \in \Sigma$ величина $\pi [q]$ содержит информацию, которая не зависит от символа $a$ и необходима для вычисления величины $\delta (q, a)$. 
Поскольку массив $\pi$ содержит только $m$ элементов (в то время как в массиве $\delta$ их $\Theta (m |\Sigma|)$, вычисляя на этапе предварительной обработки функцию $\pi$ вместо функции $\delta$, удается уменьшить время предварительной обработки образца в $|\Sigma|$ раз \cite{Cormen2013}.

Префиксная функция $\pi$, предназначенная для какого-нибудь образца, инкапсулирует сведения о том, в какой мере образец совпадает сам с собой после сдвигов. 
Эта информация позволяет избежать ненужных проверок в простейшем алгоритме поиска подстрок или предвычисления функции $\delta$ при использовании конечных автоматов \cite{Cormen2013}.

Дадим формальное определение. 
Префиксной функцией заданного образца $P[1..m]$ называется функция $\pi : {1, 2, ..., m} \to {0, 1, ..., m - 1}$, такая что
\begin{equation}
	\pi [q] = \max\{k: k < q~\text{и}~P_k \supset P_q\}.
\end{equation}

Другими словами, $\pi [q]$ равно длине наибольшего префикса образца $P$, который является истинным суффиксом строки $P_q$ \cite{Cormen2013}.

\section{Конвейерная обработка данных}

Заявка состоит из текста и строки. 
Конвейер состоит из трех лент. 
На первой происходит поиск всех вхождений строки в текст с помощью классического алгоритма поиска строки в тексте. 
На второй ленте происходит поиск всех вхождений строки в текст с помощью алгоритма Кнута-Морриса-Пратта. 
На третьей полученные результаты записываются в журнал (файл). 
В журнал для каждой заявки необходимо записать строку, количество сравнений и все вхождения строки в текст для обоих алгоритмов.

\section*{Вывод из аналитической части}

В текущем разделе были рассмотрены два алгоритма поиска строки в тексте --- классический и Кнута-Морриса-Пратта --- которые будут использоваться соответственно на первом и втором этапах конвейерной обработки данных. 
